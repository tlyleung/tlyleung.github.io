---
layout: note
title: LeetCode
description: Algorithms and data structures required to solve the majority of LeetCode problems.
authors: [tlyleung]
x: 50
y: 20
---

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/neural-swarm-1.svg width="100%" height="100%" %}</div>
# LeetCode

This cheatsheet covers the algorithms and data structures required to solve the majority of LeetCode problems. Please [contact me](https://twitter.com/tlyleung) for corrections/omissions.

*Last updated: 1 July 2024*
</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/book-flip-page.svg width="100%" height="100%" %}</div>
# Contents

- [Problem Solving](#problem-solving)
- [Complexity](#complexity)
- [Algorithms](#algorithms)
    - [Backtracking](#algorithms-backtracking) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span>
    - [Bit Manipulation](#algorithms-bit-manipulation) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span>
    - [Cascading](#algorithms-cascading) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span>
    - [Dynamic Programming](#algorithms-dynamic-programming) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span>
    - [Greedy](#algorithms-greedy) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span>
    - [Sorting](#algorithms-sorting) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
- [Data Structures](#data-structures)
    - [Array](#data-structures-array) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
    - [Binary Search Tree](#data-structures-binary-search-tree) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
    - [Graph](#data-structures-graph) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
    - [Hash Table](#data-structures-hash-table) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
    - [Heap](#data-structures-heap) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span>
    - [Linked List](#data-structures-linked-list) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
    - [Stack & Queue](#data-structures-stack--queue) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span>
    - [Trie](#data-structures-trie) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span>
    - [Union-Find](#data-structures-union-find) <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span>
- [Python](#python)
    - [`collections`](#python-collections)
    - [`functools`](#python-functools)
    - [`heapq`](#python-heapq)
    - [`itertools`](#python-itertools)
- [Advanced Topics](#advanced-topics)
</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/bulb-1.svg width="100%" height="100%" %}</div>
# Problem Solving[^bctci25][^ctci15][^patterns24]

1. **Understand the problem:** ask clarifying questions to gather constraints and edge cases.
2. **Design the algorithm:** if stuck, try:
    - optimizing the brute-force solution
    - solving an easy variant or a subproblem
    - cycling through patterns
    - articulating your blocker
3. **Get buy-in:** ask "Does this approach make sense to you?"
4. **Implement the solution:** use modular code, error checks, and good variables names.
5. **Provide complexity estimates:** give time and space complexity estimates.
6. **Verify the solution:** walk through the code line-by-line with simple input, then use boundary values to check for edge cases.

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/coding-apps-website-big-data-complexity.svg width="100%" height="100%" %}</div>
# Complexity

## $$O$$-notation, $$\Omega$$-notation, $$\Theta$$-notation

- **$$O$$-notation** provides an upper bound for the amount of time or space an algorithm will consume for any input of size $$n$$.
- **$$\Omega$$-notation** provides a lower bound for the amount of time or space an algorithm will consume for any input of size $$n$$.
- **$$\Theta$$-notation** provides a tight bound for the amount of time or space an algorithm will consume for any input of size $$n$$.

<p class="text-center">
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">O(n!)</span>
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">O(2<sup>n</sup>)</span>
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">O(n<sup>2</sup>)</span>
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">O(n log n)</span>
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">O(n)</span>
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">O(log n)</span>
    <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">O(1)</span>
</p>

{% include_relative figures/complexity.html %}

---

## Best Case, Worst Case, Average Case

- **Best Case:** minimum amount of time or space an algorithm will consume for the most favorable input of size $$n$$.
- **Worst Case:** maximum amount of time or space an algorithm will consume for any possible input of size $$n$$.
- **Average Case:** expected amount of time or space an algorithm will consume when all possible inputs of size $$n$$ are equally likely.

---

## Amortized Running Time

Allows us to describe that, yes, this worst case happens every once in a while. But once it happens, it won't happen again for so long that the cost is "amortized".

---

## Recursive Running Time

Running time for recursive functions  will often look like $$O(\textrm{branches}^\textrm{depth})$$.

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/hierarchy-3.svg width="100%" height="100%" %}</div>
# Algorithms

An algorithm is a sequence of computational steps that transform the input into the output.[^clrs22]

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/keyboard-arrow-return.svg width="100%" height="100%" %}</div>
# Algorithms: Backtracking

A backtracking algorithm finds all (or some) solutions to a problem by incrementally building candidates to the solutions. As soon as it determines that a candidate cannot lead to a final solution, it abandons the candidate ("backtracking"). Typically, problems that ask you to find all of something with low bounds can be solved with backtracking.

```python
def backtrack(path, choices):
    if is_solution(path):
        result.append(path[:])
        return
    
    for choice in choices:
        if not is_valid(choice):
            continue

        # Make the choice
        path.append(choice)

        new_choices = None  # update choices
        backtrack(path, new_choices)

        # Undo the choice (backtrack)
        path.pop()  


result = []
initial_path = []
initial_choices = get_initial_choices()

backtrack(initial_path, initial_choices)
```

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [N-Queens](https://leetcode.com/problems/n-queens/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)

### Subsets

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Permutations](https://leetcode.com/problems/permutations/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Subsets](https://leetcode.com/problems/subsets/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Subsets II](https://leetcode.com/problems/subsets-ii/)


</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/binary.svg width="100%" height="100%" %}</div>
# Algorithms: Bit Manipulation

## Bitwise Operators

### NOT `~`

Unary operation that returns the complement of `x` by flipping all the bits (0 becomes 1, and 1 becomes 0).

### AND `&`

Binary operation that returns a new number where each bit is set only if both corresponding bits in `x` and `y` are 1.

### OR `|`

Binary operation that returns a new number where each bit is set if at least one of the corresponding bits in `x` or `y` is 1.

### XOR `^`

Binary operation that returns a new number where each bit is set if the corresponding bits in `x` and `y` are different (i.e. one is 1 and the other is 0).

---

## Bit Shifts

- **Arithmetic shift:** when bits are shifted left, zeros are filled in on the right (same as logical shift), but when bits are shifted right, the sign bit is replicated to fill in the empty spaces. `x << y` is the same as multiply `x` by $$2^y$$. `x >> y` is the same as `//`-ing `x` by $$2^y$$.
- **Logical shift:** when bits are shifted left or right, empty spaces are filled with zeros.
- **Circular shift:** when bits are shifted left or right, bits that fall off are wrapped around.

---

## Boolean Algebra

- **AND**
    - `x & 0s = 0`
    - `x & 1s = x`
    - `x & x = x`
- **OR**
    - `x | 0s = x`
    - `x | 1s = 1s`
    - `x | x = x`
- **XOR**
    - `x ^ 0s = x`
    - `x ^ 1s = ~x`
    - `x ^ x = 0`

---

## Two's Complement[^ctci15]

Computers typically store integers in two's complement representation. A positive number is represented as itself while a negative number is represented as the two's complement of its absolute value (with a 1 in its sign bit to indicate a negative value). The binary representation of $$-K$$ as a $$N$$-bit number is `concat(1, 2^(N-1) - K)`. Two's complement allows the use of the same hardware circuitry for both addition and subtraction.

---

## Common Operations

```python
def get_bit(num: int, i: int) -> int:
    return (num >> i) & 1

def set_bit(num: int, i: int) -> int:
    return num | (1 << i)

def clear_bit(num: int, i: int) -> int:
    return num & ~(1 << i)

def update_bit(
    num: int,
    i: int,
    bit_is_1: bool,
) -> int:
    value = 1 if bit_is_1 else 0
    mask = ~(1 << i)
    return (num & mask) | (value << i)
```

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Add Binary](https://leetcode.com/problems/add-binary/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Missing Number](https://leetcode.com/problems/missing-number/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)

### Bitwise XOR

Use Bitwise XOR to solve problems.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Complement of Base 10 Integer](https://leetcode.com/problems/complement-of-base-10-integer/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Single Number](https://leetcode.com/problems/single-number/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Single Number II](https://leetcode.com/problems/single-number-ii/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/navigation-menu-2.svg width="100%" height="100%" %}</div>
# Algorithms: Cascading

A cascading algorithm can be used when all possible subsets (the power set) are required. While backtracking builds and discards partial solutions on the fly, cascading typically generates all intermediate states and stores them, resulting in higher space complexity.

```python
def subsets_backtracking(
    nums: List[int]
) -> List[List[int]]:
    def backtrack(path, start):
        result.append(path[:])

        for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(path, i + 1)
                path.pop()

    result = []
    backtrack([], 0)
    return result
```

```python
def subsets_cascading(
    nums: List[int]
) -> List[List[int]]:
    results = [[]]
    for num in nums:
        results.extend([result + [num]
                        for result in results])

    return results
```

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/board-game-geometry.svg width="100%" height="100%" %}</div>
# Algorithms: Dynamic Programming[^clrs22][^ctci15]

A dynamic programming algorithm improves on a recursive approach by finding overlapping subproblems and caching the result.

There are two equivalent ways of solving a Dynamic Programming problem:

- **Top-Down (Memoization):** Write the recursive solution and use a data structure (like an array or hash table) to save the result of each subproblem so that each subproblem is only computed once.
- **Bottom-Up (Tabulation):** Starting at the base cases, iteratively fill up a table in a way that depends on the already filled entries (solving smaller subproblems first). While this approach can be less space-efficient, potentially computing and storing unnecessary states, techniques like rolling arrays or state reduction can optimize space usage.

A problem is a good candidate for Dynamic Programming if: (i) it asks for the optimum value (e.g. max, min, longest, shortest) of something or the number of ways to do something or if it is possible to reach a certain point; and (ii) future decisions depend on earlier decisions, e.g. using one element prevents the usage of other elements.

---

## Steps for Solving Dynamic Programming Problems

1. Solve using recursion
2. Apply memoization
3. Pass arguments by reference instead of by value
4. Replace recursion with iteration and use a table instead of memoization

---

## Example: Fibonacci Sequence

```python
cache = dict()

def fib_top_down(n: int) -> int:
    global cache

    if n == 0 or n == 1:
        return 1
    
    if n in cache:
        return cache[n]

    cache[n] = (fib_top_down(n - 1) +
                fib_top_down(n - 2))
    return cache[n]

def fib_bottom_up(n: int) -> int:
    ans = [1, 1]

    while len(ans) <= n:
        ans.append(ans[-1] + ans[-2])
    
    return ans[n]
```

---

## Patterns

### 1-Dimensional

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Coin Change](https://leetcode.com/problems/coin-change/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

### 2-Dimensional

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Edit Distance](https://leetcode.com/problems/edit-distance/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Unique Paths](https://leetcode.com/problems/unique-paths/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/diagram-arrow-up-and-right.svg width="100%" height="100%" %}</div>
# Algorithms: Greedy

A greedy algorithm builds a solution piece-by-piece, always making a choice that looks the best at the moment and never takes back its choices. It assembles a globally optimal solution by making locally optimal (greedy) choices. Greedy algorithms are often simpler and faster than other approaches like dynamic programming, but they require a proof of correctness to ensure they work for the given problem.

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Jump Game](https://leetcode.com/problems/jump-game/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Jump Game II](https://leetcode.com/problems/jump-game-ii/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/descending-sort-1.svg width="100%" height="100%" %}</div>
# Algorithms: Sorting

## Bubble Sort

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Average: O(n<sup>2</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Worst: O(n<sup>2</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Repeatedly compare and swap adjacent elements if they are in the wrong order, effectively "bubbling" the largest unsorted element to its correct position with each full pass through the list.

```python
def bubble_sort(A: list[int]) -> None:
    n = len(A)

    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n-i-1):
            # Bubble item up to final position
            if A[j] > A[j+1]:
                A[j], A[j+1] = A[j+1], A[j]
```

---

## Heapsort

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Construct a binary heap from the data and repeatedly removes the largest element from the heap, rebuilding the heap each time, to achieve a sorted list.

```python
def max_heapify(
    A: list[int],
    n: int,
    i: int,
) -> None:
    largest = i  # initialize largest as root
    left = 2 * i + 1
    right = 2 * i + 2

    # See if left child of root exists and
    # is greater than root
    if left < n and A[left] > A[largest]:
        largest = left

    # See if right child of root exists and
    # is greater than root
    if right < n and A[right] > A[largest]:
        largest = right

    # Change root, if needed
    if largest != i:
        A[i], A[largest] = A[largest], A[i]

        # Heapify the root
        max_heapify(A, n, largest)

def build_max_heap(A: list[int]) -> None:
    n = len(A)

    for i in range(n // 2 - 1, -1, -1):
        max_heapify(A, n, i)

def heapsort(A: list[int]) -> None:
    n = len(A)

    # Build a max heap from the input array
    build_max_heap(A, n)

    # One by one extract elements from the heap
    for i in range(n - 1, 0, -1):
        # Move current root to end
        A[i], A[0] = A[0], A[i]
        # Call max_heapify on the reduced heap
        max_heapify(A, i, 0)
```
---

## Insertion Sort

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Average: O(n<sup>2</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Worst: O(n<sup>2</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Build the final sorted array one item at a time, inserting each new element into its appropriate position within the already sorted portion of the array.

```python
def insertion_sort(A: list[int]) -> None:
    for i in range(1, len(A)):
        key = A[i]
        # Insert into sorted subarray A[0..i-1]
        j = i - 1
        while j >= 0 and A[j] > key:
            A[j+1] = A[j]
            j -= 1
        A[j+1] = key
```

---

## Merge Sort

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

Recursively divide the list into halves, sorting each half, and merging the sorted halves back together.

```python
def merge(
    A: list[int],
    p: int,
    q: int,
    r: int,
) -> None:
    # Create left and right subarrays
    L = A[p:q+1]
    R = A[q+1:r+1]

    # Initial indexes for left (i),
    # right (j) and merged array (k)
    i = j = 0
    k = p

    # Merge the temp arrays back into A[p..r]
    while i < len(L) and j < len(R):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
        k += 1

    # Copy the remaining elements of L, if any
    while i < len(L):
        A[k] = L[i]
        i += 1
        k += 1

    # Copy the remaining elements of R, if any
    while j < len(R):
        A[k] = R[j]
        j += 1
        k += 1

def merge_sort(
    A: list[int],
    p: int,
    r: int,
) -> None:
    if p >= r:  # zero or one element?
        return
    q = (p + r) // 2  # mid-point of A[p:r]
    merge_sort(A, p, q)
    merge_sort(A, q + 1, r)
    # Merge A[p:q] and A[q+1:r] into A[p:r]
    merge(A, p, q, r)
```

---

## Quicksort

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Worst: O(n<sup>2</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(log n)</span>

Select a "pivot" element and partition the array into sub-arrays containing elements less than and greater than the pivot, then recursively apply the same strategy to each sub-array.

```python
def partition(
    A: list[int],
    p: int,
    r: int,
) -> int:
    pivot = A[r]  # choose last item as pivot
    i = p - 1  # highest index into low side

    # Process each element other than the pivot
    for j in range(p, r):
        # Does element belong on low side?
        if A[j] <= pivot:
            # Index of new slot on low side
            i += 1 
            # Put element there
            A[i], A[j] = A[j], A[i]

    # Pivot goes just to the right of low side
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1  # new index of the pivot

def quicksort(
    A: list[int],
    p: int,
    r: int,
) -> None:
    if p < r:
        # Partition the subarray around the pivot, which ends up in A[q]
        q = partition(A, p, r)
        quicksort(A, p, q - 1)  # recursively sort the low side
        quicksort(A, q + 1, r)  # recursively sort the high side
```

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/row-selected-single.svg width="100%" height="100%" %}</div>
# Data Structures

A data structure is a way to store and organize data in order to facilitate access and modifications.[^clrs22]
</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/row-selected-single.svg width="100%" height="100%" %}</div>
# Data Structures: Array

A collection of elements, of same memory size, each identified by an array index.

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Access: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Insert: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Access: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Insert: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Algorithms

### Boyer-Moore Majority Vote Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Use a pair-wise cancellation strategy to identify the majority element.

```python
def majority_vote(nums: list[int]) -> int:
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            # Forget previous runs
            candidate = num  
            
        # count majority element instances as +1
        # count other element instances as -1
        count += (1 if num == candidate else -1)

    return candidate
```

### Fisher-Yates Shuffle Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Randomly permute a list by iteratively swapping each element with a random element that has not been shuffled yet, ensuring each permutation is equally likely.

```python
def shuffle(arr: list[int]) -> None:
    n = len(arr)

    # Loop from 0 to n-2
    for i in range(n - 1):
        # Generate a random index from i to n-1
        j = random.randint(i, n - 1)
        # Swap the elements at indices i and j
        arr[i], arr[j] = arr[j], arr[i]
```

### Kadane's Maximum Subarray Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Use a rolling sum that resets when negative to find the largest sum of any contiguous subarray.

```python
def max_subarray(arr: list[int]) -> int:
    best_sum = -float("inf")
    current_sum = 0

    for x in arr:
        current_sum = max(x, current_sum + x)
        best_sum = max(best_sum, current_sum)
    
    return best_sum
```

### Rabin-Karp String Matching Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(n+m)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(n+m)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Worst: O(nÂ·m)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(1)</span>

Use a rolling hash function to efficiently search for pattern matches in text, allowing for quick hash comparisons and re-computation of hashes when moving the search window.

```python
def string_match(text: str, pattern: str) -> list[int]:
    n = len(text)
    m = len(pattern)
    d = 256  # number of characters in alphabet
    q = 101  # prime number

    h = pow(d, m-1) % q  # highest-order digit
    p = 0  # hash value for pattern
    t = 0  # hash value for text
    
    # Calculate hash value of pattern and first window of text
    for i in range(m):
        p = (d * p + ord(pattern[i])) % q
        t = (d * t + ord(text[i])) % q
    
    # Slide the pattern over the text one by one
    shifts = []
    for s in range(n - m + 1):
        # Check hash values of pattern and current window of text
        if p == t:
            # Check actual characters one by one
            if text[s:s+m] == pattern:
                shifts.append(s)

        # Calculate the hash value for the next window of text:
        # Remove the leading digit, add the trailing digit
        if s < n - m:
            t = (d * (t - ord(text[s]) * h) + ord(text[s + m])) % q
            # Convert negative hash to positive
            if t < 0:
                t += q

    return shifts
```

---

## Patterns[^grok19]

### Binary Search

Use a modified version of binary search.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Binary Search](https://leetcode.com/problems/binary-search/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Find Smallest Letter Greater Than Target](https://leetcode.com/problems/find-smallest-letter-greater-than-target/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

```python
def bisect_left(a, x):
    # Locate insertion point for x in sorted a
    # left of any existing entries of x in a.
    left = 0
    right = len(a) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if a[mid] < x:
            left = mid + 1
        else:
            right = mid - 1

    return left

def bisect_right(a, x):
    # Locate insertion point for x in sorted a
    # right of any existing entries of x in a.
    left = 0
    right = len(a) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if a[mid] <= x:
            left = mid + 1
        else:
            right = mid - 1

    return left
```

```python
def index_left(a, x):
    # Locate leftmost value exactly equal to x
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

def index_right(a, x):
    # Locate rightmost value exactly equal to x
    i = bisect_right(a, x)
    if i and a[i-1] == x:
        return i-1
    raise ValueError

def find_lt(a, x):
    # Locate rightmost value less than x
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_le(a, x):
    # Locate rightmost value less than or equal to x
    i = bisect_right(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_gt(a, x):
    # Locate leftmost value greater than x
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

def find_ge(a, x):
    # Locate leftmost item greater than or equal to x
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError
```

### Intervals

Merge overlapping intervals.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Insert Interval](https://leetcode.com/problems/insert-interval/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Merge Intervals](https://leetcode.com/problems/merge-intervals/)

### Prefix Sum

Use a running sum to efficiently compute subarray sums in constant time.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

### Sliding Window

Create a window into the array and move it around to gather specific information.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

### Two Pointers

Use two pointers to traverse an array from different ends or directions.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [3Sum](https://leetcode.com/problems/3sum/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/hierarchy-7-modified.svg width="100%" height="100%" %}</div>
# Data Structures: Binary Search Tree

A binary tree where the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key: int) -> None:
        if self.root is None:
            self.root = TreeNode(key)
        else:
            self._insert(self.root, key)

    def _insert(self, node: TreeNode, key: int) -> None:
        if key < node.val:
            if node.left is None:
                node.left = TreeNode(key)
            else:
                self._insert(node.left, key)
        elif key > node.val:
            if node.right is None:
                node.right = TreeNode(key)
            else:
                self._insert(node.right, key)

    def delete(self, key: int) -> None:
        self.root = self._delete(self.root, key)

    def _delete(self, node: TreeNode, key: int) -> TreeNode:
        if node is None:
            return node

        if key < node.val:
            node.left = self._delete(node.left, key)
        elif key > node.val:
            node.right = self._delete(node.right, key)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                min_larger_node = self._find_min(node.right)
                node.val = min_larger_node.val
                node.right = self._delete(node.right, min_larger_node.val)
        return node

    def _find_min(self, node: TreeNode) -> TreeNode:
        while node.left is not None:
            node = node.left
        return node

    def search(self, key: int) -> bool:
        return self._search(self.root, key)

    def _search(self, node: TreeNode, key: int) -> bool:
        if node is None:
            return False
        elif key == node.val:
            return True
        elif key < node.val:
            return self._search(node.left, key)
        else:
            return self._search(node.right, key)
```

---

## Algorithms

### Pre-Order Traversal (Recursive)

```python
def traverse(root: TreeNode) -> list[TreeNode]:
    if not root:
        return []

    return ([root.val] + 
            traverse(root.left) +
            traverse(root.right))
```

### Pre-Order Traversal (Iterative)

```python
def traverse(root: TreeNode) -> list[TreeNode]:
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        if node.right:
            stack.append(node.right)

        if node.left:
            stack.append(node.left)

    return result
```

### In-Order Traversal (Recursive)

```python
def traverse(root: TreeNode) -> list[TreeNode]:
    if not root:
        return []

    return (traverse(root.left) +
            [root.val] +
            traverse(root.right))
```

### In-Order Traversal (Iterative)

```python
def traverse(root: TreeNode) -> list[TreeNode]:
    result = []
    stack = []

    node = root
    while node or stack:
        while node:
            stack.append(node)
            node = node.left
        
        node = stack.pop()
        result.append(node.val)
        node = node.right

    return result
```

### Post-Order Traversal (Recursive)

```python
def traverse(root: TreeNode) -> list[TreeNode]:
    if not root:
        return []

    return (traverse(root.left) +
            traverse(root.right) +
            [root.val])
```

### Post-Order Traversal (Iterative)

```python
def traverse(root: TreeNode) -> list[TreeNode]:
    if not root:
        return []

    result = []
    stack = [root]
    while stack:
        node = stack.pop()
        result.append(node.val)

        if node.left:
            stack.append(node.left)
        
        if node.right:
            stack.append(node.right)

    return reversed(result)
```

--- 

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Search: O(log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Insert: O(log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Delete: O(log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Insert: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### Breadth-first Search

Traverse tree level-by-level.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)

### Depth-first Search

Traverse tree depth-wise.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Path Sum](https://leetcode.com/problems/path-sum/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/hierarchy-9.svg width="100%" height="100%" %}</div>
# Data Structures: Graph

A collection of nodes and edges. Edges can be directed and have weights.

```python
type Graph = dict[int, dict[int, float]]

def add_vertex(
    graph: Graph,
    v: int,
) -> None:
    if v not in graph:
        graph[v] = {}

def remove_vertex(
    graph: Graph,
    v: int,
) -> None:
    if v in graph:
        # Remove the vertex
        del graph[v]
        
        # Remove all edges to this vertex
        for edges in graph.values():
            if vertex in edges:
                del edges[vertex]

def add_edge(
    graph: Graph,
    u: int,
    v: int,
    weight: float,
) -> None:
    if u not in graph:
        graph[u] = {}
    graph[u][v] = weight

def remove_edge(
    graph: Graph,
    u: int,
    v: int,
) -> None:
    if u in graph and v in graph[u]:
        del graph[u][v]
```

### Minimum Spanning Tree

A subgraph that connects all the vertices in the original graph with no cycles and exactly $$n-1$$ edges, while minimising total edge weight.

---

## Algorithms

### Bellman-Ford's Single-Source Shortest Path Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(VÂ·E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(VÂ·E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(VÂ·E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V)</span>

Relax edges repeatedly to find the shortest path from a single source to all other vertices, effectively handling graphs with negative weight edges.

```python
def bellman_ford(
    graph: Graph,
    source: int,
) -> dict[int, float] | None:
    # Initialize distances
    dist = {u: float('inf') for u in graph}
    dist[source] = 0

    # Relax edges repeatedly
    for _ in range(len(graph) - 1):
        for u in graph:
            for v, weight in graph[u].items():
                if dist[u] + weight < dist[v]:
                    dist[v] = dist[u] + weight

    # Check for negative-weight cycles
    for u in graph:
        for v, weight in graph[u].items():
            if dist[u] + weight < dist[v]:
                # Error: Negative weight cycle
                return None

    return dist
```

### Dijkstra's Single-Source Shortest Path Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(V+EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(V+EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(V+EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V)</span>

Use a priority queue to greedily select the nearest vertex not yet processed and perform relaxations efficiently. This algorithm doesn't handle graphs with negative weights.

```python
from heapq import heappush, heappop

def dijkstra(
    graph: Graph,
    source: int,
) -> dict[int, float]:
    # Initialize all distances with infinity
    dist = {u: float('inf') for u in graph}
    dist[source] = 0

    # Previous node in optimal path
    prev = {u: None for u in graph}

    # Priority queue: (curr_dist, vertex)
    min_heap = [(0, source)]

    while min_heap:
        curr_dist, u = heappop(min_heap)

        # Skip if there's already a better way
        if curr_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            alt = curr_dist + weight
            # Only consider new path if better
            if alt < dist[v]:
                dist[v] = alt
                prev[v] = u
                heappush(min_heap, (alt, v))

    return dist
```

### FloydâWarshall's All-Pairs Shortest Path Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Best: O(V<sup>3</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Average: O(V<sup>3</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Worst: O(V<sup>3</sup>)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Space: O(V<sup>2</sup>)</span>

Dynamically calculate shortest paths between all pairs of vertices using a matrix-based approach, leveraging the principle of transitivity.

```python
def floyd_warshall(graph: Graph) -> dict[int, dict[int, float]]:
    # Initialize distances with infinity
    dist = defaultdict(lambda: defaultdict(lambda: float('inf')))
    
    # Set edges to weight
    for u in graph:
        for v, weight in graph[u].items():
            dist[u][v] = weight

    # Set diagonals to zero
    for v in graph:
        dist[v][v] = 0

    # Floyd-Warshall algorithm
    for k in graph:
        for i in graph:
            for j in graph:
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    return dist
```

### Kahn's Directed Acyclic Graph Topological Sort Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(V+E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(V+E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(V+E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V)</span>

Use in-degree counts to find a "safe" order of nodes such that every node appears before its successors.

```python
from collections import deque

def kahn_topological_sort(
    graph: Graph,
) -> list[int] | None:
    # Calculate in-degrees of each node
    in_degree = {u: 0 for u in graph}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    
    # Queue of all vertices with in-degree 0
    queue = deque([u for u in graph
                   if in_degree[u] == 0])

    top_order = []

    while queue:
        u = queue.popleft()
        top_order.append(u)

        # Decrease in-degree of each neighbor
        # and check if it becomes zero
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)

    # Check there was no cycle in the graph,
    # i.e., all edges are removed
    if len(top_order) == len(in_degree):
        return top_order
    else:
        # Error: Cycle detected in graph
        return None
```

### Kruskal's Minimum Spanning Tree Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V)</span>

Add edges in increasing weight order to a growing forest, using a Union-Find data structure to avoid cycles.

```python
def kruskal_mst(
    graph: Graph,
) -> set[tuple[int, int]]:
    uf = UnionFind(len(graph))
    mst = set()

    # Sort edges by weight
    edges = [u, v, graph[u][v]
             for u in graph
             for v in graph[u]]
    edges.sort(key=lambda x: x[2])

    for u, v, weight in edges:
        if not uf.connected(u, v):
            mst.add((u, v))
            uf.union(u, v)
    
    return mst
```

### Prim's Minimum Spanning Tree Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Best: O(EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Average: O(EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Worst: O(EÂ·log V)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V)</span>

Grow the minimum spanning tree by starting from an arbitrary vertex and greedily adding the least weight edge connecting the tree to another vertex.


```python
from heapq import heappush, heappop

def prim_mst(
    graph: Graph,
    start: int,
) -> set[tuple[int, int]]:
    parent = {u: None for u in graph}
    key = {u: float('inf') for u in graph}

    # No cost to begin from start vertex
    key[start] = 0 

    # Fill priority queue with all vertices
    min_heap = []
    for v in graph:
        heappush(min_heap, (key[v], v))

    visited = set()

    while min_heap:
        # Extract vertex with minimum key
        _, u = heappop(min_heap)

        if u in visited:
            continue
        else:
            visited.add(u)

        # Process all adjacent vertices of u
        for v, weight in graph[u].items():
            if v in visited:
                continue

            if weight < key[v]:
                parent[v] = u
                key[v] = weight
                # Instead of decrease-key, push
                # new key with vertex to queue
                heappush(min_heap, (weight, v))

        # Prepare result edges from parent map
        mst = [(parent[v], v, key[v])
               for v in parent
               if parent[v] is not None]

        return mst
```

### Hierholzer's Eulerian Path Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Best: O(E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Average: O(E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Worst: O(E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V+E)</span>

Build an Eulerian Path by repeatedly finding and merging cycles within the graph until all edges are included in a single path.

### A* Pathfinding Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Best: O(E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Average: O(E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Worst: O(E)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Space: O(V)</span>

Combine heuristics with Dijkstra's algorithm to efficiently find the shortest path, prioritizing paths that appear to lead directly to the goal.

```python
from heapq import heappush, heappop

def a_star(
    graph: Graph,
    start: int,
    goal: int,
    h: Callable[[int, int], float],
) -> tuple[dict[int, float], dict[int, int]]:
    # Initialize all distances with infinity
    dist = {u: float('inf') for u in graph}
    dist[start] = 0

    # Previous node in optimal path
    prev = {u: None for u in graph}

    # Priority queue:
    # (est_cost, curr_dist, vertex)
    min_heap = [(h(start, goal), 0, start)]

    while min_heap:
        _, curr_dist, u = heappop(min_heap)

        # Early exit if reaching the goal
        if u == goal:
            return dist, prev

        for v, weight in graph[u].items():
            alt = curr_dist + weight
            if alt < dist[v]:
                dist[v] = alt
                prev[v] = u
                est_cost = alt + h(v, goal)
                item = (est_cost, alt, v)
                heappush(min_heap, item)

    return dist, prev

def h(v: int, goal: int) -> float:
    # Heuristic function estimating the cost to
    # reach goal from vertex v
    return abs(goal - v)  # Manhattan distance
```

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Network Delay Time](https://leetcode.com/problems/network-delay-time/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)

### Island

Traverse a matrix to find contiguous groups of elements.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Flood Fill](https://leetcode.com/problems/flood-fill/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Max Area of Island](https://leetcode.com/problems/max-area-of-island/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Number of Islands](https://leetcode.com/problems/number-of-islands/)

### Topological Sort

Sort nodes in a directed graph such that for every directed edge $$(u, v)$$ from vertex $$u$$ to vertex $$v$$, $$u$$ comes before $$v$$ in the ordering.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Course Schedule](https://leetcode.com/problems/course-schedule/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/workflow-data-table-2.svg width="100%" height="100%" %}</div>
# Data Structures: Hash Table

A hash table is a data structure that maps keys to values for highly efficient lookup. Usually implemented as an array of linked lists and a hashing function.

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Search: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Insert: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Delete: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Insert: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Two Sum](https://leetcode.com/problems/two-sum/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Valid Anagram](https://leetcode.com/problems/valid-anagram/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/hierarchy-4.svg width="100%" height="100%" %}</div>
# Data Structures: Heap

Tree-based data structure that satisfies the heap property:
- In a max heap, the key of parent nodes is greater than or equal to the key of child nodes.
- In a min heap, the key of parent nodes is less than or equal to the key of child nodes.

```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, element: int) -> None:
        self.heap.append(element)
        self._bubble_up(len(self.heap) - 1)

    def pop(self) -> int:
        if not self.heap:
            return None
        elif len(self.heap) == 1:
            return self.heap.pop()
        
        min_element = self.heap[0]
        # Move the last element to the root and heapify down
        self.heap[0] = self.heap.pop()
        self._bubble_down(0)
        return min_element

    def peek(self) -> int:
        min_element = self.heap[0]
        return min_element

    def _bubble_up(self, index: int) -> None:
        while index > 0:
            parent_index = (index - 1) // 2
            if self.heap[index] < self.heap[parent_index]:
                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]
                index = parent_index
            else:
                break

    def _bubble_down(self, index: int) -> None:
        length = len(self.heap)
        while True:
            left_child = 2 * index + 1
            right_child = 2 * index + 2
            smallest = index

            if left_child < length and self.heap[left_child] < self.heap[smallest]:
                smallest = left_child
            if right_child < length and self.heap[right_child] < self.heap[smallest]:
                smallest = right_child
            if smallest != index:
                self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
                index = smallest
            else:
                break
```

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Push: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Pop: O(log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Peek: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Push: O(log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Pop: O(log n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Peek: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### $$k$$-way Merge

Merge $$k$$ sorted lists.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)

### Top-$$k$$ Elements

Find the top-$$k$$ elements in a certain category.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Kth Largest Element in a Stream ](https://leetcode.com/problems/kth-largest-element-in-a-stream/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

### Two Heaps

To find the median, use two heaps: a min heap to find the smallest element in one part and a max heap to find the largest element in the other part.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [IPO](https://leetcode.com/problems/ipo/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/coding-apps-website-web-form-progress-1.svg width="100%" height="100%" %}</div>
# Data Structures: Linked List

A data structure that represents a sequence of nodes, with each element pointing to the next.

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, val: int) -> None:
        if not self.head:
            self.head = ListNode(val)
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = ListNode(val)

    def prepend(self, val: int) -> None:
        new_head = ListNode(val)
        new_head.next = self.head
        self.head = new_head

    def delete(self, val: int) -> None:
        cur_node = self.head

        if cur_node and cur_node.val == val:
            # Delete from beginning
            self.head = cur_node.next
            cur_node = None
            return

        prev = None
        while cur_node and cur_node.val != val:
            prev = cur_node
            cur_node = cur_node.next

        if cur_node is None:
            # Not found
            return

        prev.next = cur_node.next
        cur_node = None
```

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Append: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Prepend: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Append: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Prepend: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [LRU Cache](https://leetcode.com/problems/lru-cache/)

### Fast & Slow Pointers

Two pointers move at different speeds in a linked list in order to detect cycles or find middle elements.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)

### In-place Reversal of a Linked List

Reverse elements of a linked list in-place.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Reorder List](https://leetcode.com/problems/reorder-list/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/column-selected-single.svg width="100%" height="100%" %}</div>
# Data Structures: Stack & Queue

## Stack

Last in, first out data structure.

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item: int) -> None:
        self.stack.append(item)

    def pop(self) -> int:
        if self.is_empty():
            print("Pop from empty stack")
            return None
        return self.stack.pop()

    def peek(self) -> int:
        if self.is_empty():
            print("Peek from empty stack")
            return None
        return self.stack[-1]

    def is_empty(self) -> bool:
        return len(self.stack) == 0
```

---

## Queue

First in, first out data structure.

```python
from collections import deque

class Queue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, item: int) -> None:
        self.queue.append(item)

    def dequeue(self) -> int:
        if self.is_empty():
            print("Dequeue from empty queue")
            return None
        return self.queue.popleft()

    def peek(self) -> int:
        if self.is_empty():
            print("Peek from empty queue")
            return None
        return self.queue[0]

    def is_empty(self) -> bool:
        return len(self.queue) == 0
```

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Push: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Pop: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Peek: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Push: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Pop: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Peek: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Min Stack](https://leetcode.com/problems/min-stack/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

### Monotonic Stack

Use a stack to maintain a monotonic (either entirely non-increasing or non-decreasing) order of elements.

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)

```python
# Template
stack = []
for num in nums:
    while stack and stack[-1] < num:
        old_num = stack.pop()
        # Do something with old_num
    stack.append(num)
```
</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/hierarchy-4.svg width="100%" height="100%" %}</div>
# Data Structures: Trie

A tree data structure used to store and re<u>trie</u>ve a set of strings.

```python
class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            node = node.setdefault(c, {})
        node['$'] = True  # string terminal key

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node:
                return False
            node = node[c]
        return '$' in node
```

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Insert: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Insert: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Delete: O(n)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Easy</span> [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Word Break](https://leetcode.com/problems/word-break/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-red-500/15 text-red-700 group-data-[hover]:bg-red-500/25 dark:bg-red-500/10 dark:text-red-400 dark:group-data-[hover]:bg-red-500/20">Hard</span> [Word Search II](https://leetcode.com/problems/word-search-ii/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/hierarchy-4.svg width="100%" height="100%" %}</div>
# Data Structures: Union-Find

Stores a collection of disjoint (non-overlapping) sets.

```python
class UnionFind:
    def __init__(self, size: int):
        self.count = size
        self.parent = list(range(size))

    def find(self, x: int) -> int:
        while self.parent[x] != x:
            x = self.parent[x]
        return x

    def union(self, x: int, y: int) -> None:
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            self.parent[rootX] = rootY
            self.count -= 1

    def connected(self, x: int, y: int) -> bool:
        rootX = self.find(x)
        rootY = self.find(y)
        return rootX == rootY
```

### Optimisation: Path Compression

Make every node between the query node and the root point to the root.

```python
class UnionFind:
    def __init__(self, size: int):
        ...

    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x: int, y: int) -> None:
        ...

    def connected(self, x: int, y: int) -> bool:
        ...
```

### Optimisation: Union-by-Rank

Ensure that when two trees are unioned, the shorter tree (lower rank) is attached under the root of the taller tree (higher rank) to keep the overall structure as flat as possible. The rank represents the approximate height of the tree.

```python
class UnionFind:
    def __init__(self, size: int):
        ...
        self.rank = [0] * size

    def find(self, x: int) -> int:
        ...

    def union(self, x: int, y: int) -> None:
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX == rootY:
            return
        elif self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        elif self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1

        self.count -= 1

    def connected(self, x: int, y: int) -> bool:
        ...
```

---

## Complexity

### Average Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(Î±(n)) (amortized)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Insert: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

### Worst Case

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Search: O(Î±(n)) (amortized)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-green-500/15 text-green-700 group-data-[hover]:bg-green-500/25 dark:bg-green-500/10 dark:text-green-400 dark:group-data-[hover]:bg-green-500/20">Insert: O(1)</span>
<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Space: O(n)</span>

---

## Patterns

### Key Problems

- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Number of Provinces](https://leetcode.com/problems/number-of-provinces/)
- <span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Medium</span> [Redundant Connection](https://leetcode.com/problems/redundant-connection/)

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/python-logo.svg width="100%" height="100%" %}</div>
# Python

Simple statements.

## `global`

Declare that a variable inside a nested function refers to a variable in the nearest enclosing scope that is not global.

## `nonlocal`

Declare that a variable inside a function refers to a globally defined variable.

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/python-logo.svg width="100%" height="100%" %}</div>
# Python: `collections`

Container datatypes.

## `Counter`

Dict subclass for counting hashable objects.

```python-repl
>>> Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
```
---

## `defaultdict`

Dict subclass that calls a factory function to supply missing values.

```python-repl
>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
>>> d = defaultdict(list)
>>> for k, v in s:
...     d[k].append(v)
...
>>> sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]
```
---

## `deque`

List-like container with fast appends and pops on either end. Implemented using a doubly-linked list. Supports `appendleft` and `popleft`.

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/python-logo.svg width="100%" height="100%" %}</div>
# Python: `functools`

Higher-order functions and operations on callable objects.

## `@functools.cache(user_function)`

Simple lightweight unbounded function cache.

```python
@functools.cache
def factorial(n: int) -> int:
  return n * factorial(n-1) if n else 1
```

```python-repl
>>> factorial(10)  # no previously cached result, makes 11 recursive calls
3628800
>>> factorial(5)  # just looks up cached value result
120
>>> factorial(12)  # makes two new recursive calls, the other 10 are cached
479001600
```

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/python-logo.svg width="100%" height="100%" %}</div>
# Python: `heapq`

Heap queue algorithm.

## `heappush(heap, item)`

Push the value item onto the heap, maintaining the heap invariant.

---

## `heappop(heap)`

Pop and return the smallest item from the heap, maintaining the heap invariant. 

---

## `heapify(x)`

Transform list x into a heap, in-place, in linear time.

---

## `nlargest(n, iterable, key=None)`

Return a list with the n largest elements from the dataset defined by iterable.

---

## `nsmallest(n, iterable, key=None)`

Return a list with the n smallest elements from the dataset defined by iterable.

</section>

<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/python-logo.svg width="100%" height="100%" %}</div>
# Python: `itertools`

Functions creating iterators for efficient looping

## `combinations(iterable, r)`

Return r length subsequences of elements from the input iterable.

---

## `islice(iterable, stop)`

Make an iterator that returns selected elements from the iterable.

---

## `permutations(iterable, r=None)`

Return successive r length permutations of elements from the iterable.

---

## `product(*iterables, repeat=1)`

Cartesian product of input iterables.

---

## `zip_longest(*iterables, fillvalue=None)`

Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with `fillvalue`.

</section>


<section class="relative mb-4 break-inside-avoid-column overflow-hidden rounded-md bg-zinc-50 px-4 py-2 dark:bg-zinc-800" markdown="1">
<div class="absolute -top-2 right-4 h-16 w-16 text-zinc-200 dark:text-zinc-900">{% svg /assets/images/streamline/lab-flask-experiment.svg width="100%" height="100%" %}</div>
# Advanced Topics

## Algorithms

### Horner's Method

Recursive algorithm for polynomial evaluation.

$$\begin{eqnarray} 
 && a_0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n \\
&=& a_0 + x \Big(a_1 + x \big(a_2 + \cdots + x(a_{n-1} + x \, a_n) \cdots \big) \Big)
\end{eqnarray}$$

### BoyerâMoore String-Searching Algorithm

Skips sections of the text by aligning the pattern from right to left and leveraging mismatches to jump over portions of the text, making it efficient for large alphabets.

### Knuth-Morris-Pratt (KMP) String-Searching Algorithm

Avoids redundant comparisons by precomputing a partial match table (or "prefix" table) that allows the pattern to "jump" over mismatched characters, enabling efficient pattern searching in linear time.

### RabinâKarp String-Searching Algorithm

Finds a pattern by hashing the pattern and substrings of the text, allowing for quick comparisons and the ability to skip checking if the hash values do not match, making it especially useful for multiple pattern searches.

### Manacher's Longest Palindromic Substring Algorithm

<span class="whitespace-nowrap rounded-md px-1.5 py-0.5 text-sm/5 font-medium sm:text-xs/5 bg-yellow-400/20 text-yellow-700 group-data-[hover]:bg-yellow-400/30 dark:bg-yellow-400/10 dark:text-yellow-300 dark:group-data-[hover]:bg-yellow-400/15">Time: O(n)</span>

Expand around possible centers while leveraging previously computed results to minimize redundant checks, achieving linear time complexity.

### QuickSelect

## Data Structures

- Fenwick Tree: Efficiently update values and calculate prefix sums in an array of values.
- Interval Tree: TODO
- Segment Tree with Lazy Propagation and Coordinate Compression: TODO

## Theory

### NP-Complete Problems

No polynomial-time algorithm is currently known to solve these problems optimally.

- Hamiltonian path problem
- Knapsack problem
- Subset sum problem
- Traveling salesman problem
- Vertex cover problem

### Pick's Theorem

Determine the area of a polygon with integer vertex coordinates when given the number of integer interior ($$i$$) and boundary ($$b$$) points: $$A = i + \frac{b}{2} - 1$$.

### Shoelace Formula

Determine the area of a polygon with integer points.

### Stirling's Approximation for $$n!$$

$$\ln(n!) = n\ln n - n +O(\ln n)$$

</section>

[^bctci25]: [Beyond Cracking the Coding Interview](https://www.beyondctci.com/)
[^clrs22]: [Introduction to Algorithms, Fourth Edition.](https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/)
[^ctci15]: [Cracking the Coding Interview, Sixth Edition.](https://www.crackingthecodinginterview.com/)
[^ddia17]: [Designing Data-Intensive Applications](https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/)
[^epi12]:  [Elements of Programming Interviews](https://elementsofprogramminginterviews.com/)
[^grok19]: [Grokking the Coding Interview](https://www.designgurus.io/course/grokking-the-coding-interview/)
[^patterns24]: [Coding Interview Patterns](https://bytebytego.com/)
